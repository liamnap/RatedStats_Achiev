name: Finalize PvP Sync
run-name: Finalize PvP Sync for ${{ inputs.region }}

# Trigger whenever the "PvP Sync Batch" workflow finishes on dev
on:
  workflow_run:
    workflows: ["PvP Sync Batch"]
    types: [completed]
  workflow_dispatch:
    inputs:
      region:
        description: "Region to finalize"
        required: true
        type: choice
        options: [kr, tw, eu, us]
      sha:
        description: "Head SHA of the batch runs to finalize"
        required: true
        type: string
      branch:
        description: "Branch the batch runs executed on"
        required: true
        type: string

permissions:
  contents: write
  actions: read

jobs:
  guard:
    # fire on: (a) workflow_dispatch, or (b) any "PvP Sync Batch" completion (all regions)
    if: >
      (github.event_name == 'workflow_dispatch') ||
      (github.event.workflow_run.name == 'PvP Sync Batch')
    name: Check if this was the last batch
    runs-on: ubuntu-latest
    concurrency:
      # one finalize per region+sha regardless of trigger type
      group: finalize-${{ needs.guard.outputs.region }}-${{ github.event.workflow_run.head_sha || inputs.sha || github.sha }}
      cancel-in-progress: false
    outputs:
      is_final: ${{ steps.parse.outputs.is_final }}
      region:   ${{ steps.parse.outputs.region }}
    steps:
      - name: Determine region + whether this is the final batch
        id: parse
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "region=${{ inputs.region }}" >>"$GITHUB_OUTPUT"
            echo "is_final=true" >>"$GITHUB_OUTPUT"
            echo "üü¢ Finalize via dispatch: region='${{ inputs.region }}'"
            exit 0
          fi

          TITLE="${{ github.event.workflow_run.display_title }}"
          echo "Run title: $TITLE"
          # Expect: "PvP Sync Batch 3 / 10 for kr"
          if [[ "$TITLE" =~ ^PvP[[:space:]]Sync[[:space:]]Batch[[:space:]]([0-9]+)[[:space:]]*/[[:space:]]*([0-9]+)[[:space:]]for[[:space:]]([a-z]{2})$ ]]; then
            CUR="${BASH_REMATCH[1]}"; TOT="${BASH_REMATCH[2]}"; REGION="${BASH_REMATCH[3]}"
            echo "region=$REGION" >>"$GITHUB_OUTPUT"
            if [[ "$CUR" == "$TOT" ]]; then
              echo "is_final=true"  >>"$GITHUB_OUTPUT"
              echo "‚úÖ Detected final batch ($CUR/$TOT) for $REGION"
            else
              echo "is_final=false" >>"$GITHUB_OUTPUT"
              echo "‚è≠ Not final batch ($CUR/$TOT) for $REGION ‚Üí skipping finalize."
            fi
          else
            echo "is_final=false" >>"$GITHUB_OUTPUT"
            echo "‚ö†Ô∏è Couldn't parse batch info; aborting finalize."
          fi

  finalize:
    if: >
      needs.guard.outputs.is_final == 'true' &&
      (
        (github.event_name == 'workflow_run'     && github.event.workflow_run.conclusion == 'success')
        ||
        (github.event_name == 'workflow_dispatch')
      )
    needs: guard
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.workflow_run.head_branch || inputs.branch }}
          lfs: true   # make sure any LFS pointers are hydrated if present

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Enable Git LFS
        run: |
          git lfs install --local
          git lfs env

      - name: Install runtime deps
        run: |
          python -m pip install --upgrade pip
          pip install aiohttp requests psutil

      - name: Wait for ALL region batch runs to complete
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          wf="PvP Sync Batch"
          region="${{ needs.guard.outputs.region }}"
          sha="${{ github.event.workflow_run.head_sha }}"
          branch="${{ github.event.workflow_run.head_branch }}"
          # Fallbacks for workflow_dispatch
          if [[ -z "$sha" ]]; then sha="${{ inputs.sha }}"; fi
          if [[ -z "$branch" ]]; then branch="${{ inputs.branch }}"; fi
          echo "Waiting for all '$wf' runs for region=$region, sha=$sha..."
          while true; do
            # find any runs still pending/running for this sha+region
            rem=$(gh run list \
                  -w "$wf" -b "$branch" -L 500 \
                  --json status,displayTitle,headSha \
                  --jq "[ .[]
                          | select(.headSha==\"$sha\")
                          | select(.displayTitle|endswith(\" for $region\"))
                          | select(.status!=\"completed\") ] | length")
            if (( rem == 0 )); then
              echo "‚úÖ All $wf runs for $region/$sha are done."
              break
            fi
            echo "‚è≥ $rem runs still in progress‚Ä¶"
            sleep 10
          done

      - name: Download every batch‚Äôs DB shard
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          wf="PvP Sync Batch"
          region="${{ needs.guard.outputs.region }}"
          sha="${{ github.event.workflow_run.head_sha }}"
          branch="${{ github.event.workflow_run.head_branch }}"
          # Fallbacks for workflow_dispatch
          if [[ -z "$sha" ]]; then sha="${{ inputs.sha }}"; fi
          if [[ -z "$branch" ]]; then branch="${{ inputs.branch }}"; fi
          mkdir -p partial_outputs
          # grab the list of run IDs for this sha+region
          ids=$(gh run list \
                  -w "$wf" -b "$branch" -L 500 \
                  --json databaseId,displayTitle,headSha \
                  --jq "[ .[]
                            | select(.headSha==\"$sha\")
                            | select(.displayTitle|endswith(\" for $region\"))
                            | .databaseId ] | unique | .[]")
          # download only the DB artifacts for this region, into a temp dir
          rm -rf _dl && mkdir -p _dl
          for id in $ids; do
            echo "Downloading DB artifacts from run $id‚Ä¶"
            gh run download "$id" \
              --pattern "pvp-db-${region}-batch-*" \
              -D _dl || true
          done
          # flatten sqlite shards into ./partial_outputs (handle any nested layout)
          shopt -s globstar nullglob
          found_any=0
          for f in _dl/**/achdb_${region}_b*.sqlite; do
            echo "Copying shard: $f"
            cp -f "$f" partial_outputs/
            found_any=1
          done
          if [[ $found_any -eq 0 ]]; then
            echo "‚ùå No achdb_${region}_b*.sqlite found under _dl/"
            echo "Directory tree for debugging:"
            ls -laR _dl || true
          fi
          echo "Found shards:"
          ls -1 partial_outputs || true
          # ensure no temp junk will ever be accidentally committed
          git clean -fdx
          # hard stop if we didn't actually get any shards for this region/SHA
          cnt=$(ls -1 partial_outputs/achdb_${region}_b*.sqlite 2>/dev/null | wc -l || true)
          if (( cnt == 0 )); then
            echo "‚ùå No shards found for region=$region sha=$sha branch=$branch"
            exit 1
          fi
          # show a per-shard row count as a sanity check
          for dbf in partial_outputs/achdb_${region}_b*.sqlite; do
            echo -n "rows in $(basename "$dbf"): "
            sqlite3 "$dbf" "SELECT COUNT(*) FROM char_data;" || true
          done

      - name: Finalize region file
        env:
          REGION: ${{ needs.guard.outputs.region }}
          BLIZZARD_CLIENT_ID:     ${{ secrets.BLIZZARD_CLIENT_ID }}
          BLIZZARD_CLIENT_SECRET: ${{ secrets.BLIZZARD_CLIENT_SECRET }}
          BLIZZARD_CLIENT_ID_EU:     ${{ secrets.BLIZZARD_CLIENT_ID_EU }}
          BLIZZARD_CLIENT_SECRET_EU: ${{ secrets.BLIZZARD_CLIENT_SECRET_EU }}
          BLIZZARD_CLIENT_ID_US:     ${{ secrets.BLIZZARD_CLIENT_ID_US }}
          BLIZZARD_CLIENT_SECRET_US: ${{ secrets.BLIZZARD_CLIENT_SECRET_US }}
          # finalize doesn‚Äôt actually use these, but the script reads them at import time
          BATCH_SIZE: "1"
          BATCH_ID: "0"
          TOTAL_BATCHES: "1"
          OFFSET: "0"
          LIMIT: "1"
        run: |
          set -euo pipefail
          echo "Merging batches and writing final region_${REGION}.lua‚Ä¶"
          python sync_pvp.py --mode finalize --region "$REGION"

      - name: Region file is LFS-tracked
        run: |
          git check-attr filter "region_${{ needs.guard.outputs.region }}.lua"
          git lfs ls-files | grep "region_${{ needs.guard.outputs.region }}.lua" || { echo "Not tracked by LFS"; exit 1; }

      - name: Commit & push finalized .lua
        run: |
          set -euo pipefail
          BRANCH="${{ github.event.workflow_run.head_branch || inputs.branch }}"
          git config user.name  "GitHub Action"
          git config user.email "action@github.com"
          git add -A
          git commit -m "Finalize PvP sync for ${{ needs.guard.outputs.region }}" || true
          tries=0; max=6
          while :; do
            if git push origin "HEAD:${BRANCH}"; then
              echo "‚úÖ Pushed to ${BRANCH}"
              break
            fi
            tries=$((tries+1))
            if (( tries >= max )); then
              echo "‚ùå Push failed after ${max} attempts"
              exit 1
            fi
            echo "‚ö†Ô∏è  Push rejected; rebasing onto origin/${BRANCH} and retrying (${tries}/${max})‚Ä¶"
            git fetch origin "${BRANCH}"
            git rebase --abort || true
            git rebase "origin/${BRANCH}" || { git rebase --abort; git pull --rebase origin "${BRANCH}"; }
            sleep $((2 * tries))
          done

      - name: Tag this commit (vA.BB [+ -beta] + date)
        run: |
          set -euo pipefail
          BRANCH="${{ github.event.workflow_run.head_branch || inputs.branch }}"

          # Use London time for the date suffix
          TZ="Europe/London" ; export TZ
          DATE="$(date +%F)"  # YYYY-MM-DD

          # Make sure we see *all* tags
          git fetch --tags --force --prune

          # Find the highest base like vA.BB, ignoring any suffixes (-beta/-DATE)
          last_base="$(git tag -l 'v*' \
                        | sed -E 's/^(v[0-9]+\.[0-9]+).*/\1/' \
                        | sort -u -V | tail -n1)"

          if [[ -z "${last_base:-}" ]]; then
            major=1; minor=0
          else
            major="$(sed -E 's/^v([0-9]+)\..*/\1/' <<<"$last_base")"
            minor="$(sed -E 's/^v[0-9]+\.([0-9]+).*/\1/' <<<"$last_base")"
          fi
          next_minor=$((10#$minor + 1))
          base="v${major}.${next_minor}"

          suffix=""
          if [[ "$BRANCH" == "dev" ]]; then
            suffix="-beta"
          fi
          tag="${base}${suffix}-${DATE}"

          # Idempotency: skip if it already exists (e.g., another region finalized first)
          if git rev-parse -q --verify "refs/tags/${tag}" >/dev/null; then
            echo "‚ÑπÔ∏è Tag ${tag} already exists; nothing to do."
            exit 0
          fi

          git tag -a "${tag}" -m "Automated tag for ${BRANCH} ${tag}"
          git push origin "refs/tags/${tag}"
