name: Dispatch PvP Sync Batches
on:
  workflow_dispatch:
    inputs:
      region:
        description: "Region to run (select a region or 'all')"
        required: false
        type: choice
        options: [all, kr, tw, eu, us]
        default: all
  schedule:
    - cron: '0 1 * * *'

permissions:
  actions: write   # needed to call createWorkflowDispatch
  contents: read

concurrency:
  group: pvp-sync-dispatcher-${{ github.ref }}
  cancel-in-progress: false

env:
  BATCH_SIZE: 2500
  MAX_BATCHES_PER_CRED: 20    # ~50k characters = 20 * 2500
  SUFFIX_LIST: '"_1","_2","_3","_4","_5","_429"'  # Customize per region
  # REGIONS is resolved dynamically below (supports 'all' or blank)

jobs:
  prepare:
    runs-on: ubuntu-latest
    env:
      BLIZZARD_CLIENT_ID_EU_1:     ${{ secrets.BLIZZARD_CLIENT_ID_EU_1 }}
      BLIZZARD_CLIENT_SECRET_EU_1: ${{ secrets.BLIZZARD_CLIENT_SECRET_EU_1 }}
      BLIZZARD_CLIENT_ID_US_1:     ${{ secrets.BLIZZARD_CLIENT_ID_US_1 }}
      BLIZZARD_CLIENT_SECRET_US_1: ${{ secrets.BLIZZARD_CLIENT_SECRET_US_1 }}
      BLIZZARD_CLIENT_ID_TW_1:     ${{ secrets.BLIZZARD_CLIENT_ID_TW_1 }}
      BLIZZARD_CLIENT_SECRET_TW_1: ${{ secrets.BLIZZARD_CLIENT_SECRET_TW_1 }}
      BLIZZARD_CLIENT_ID_KR_1:     ${{ secrets.BLIZZARD_CLIENT_ID_KR_1 }}
      BLIZZARD_CLIENT_SECRET_KR_1: ${{ secrets.BLIZZARD_CLIENT_SECRET_KR_1 }}
      
      BLIZZARD_CLIENT_ID_EU_2:     ${{ secrets.BLIZZARD_CLIENT_ID_EU_2 }}
      BLIZZARD_CLIENT_SECRET_EU_2: ${{ secrets.BLIZZARD_CLIENT_SECRET_EU_2 }}
      BLIZZARD_CLIENT_ID_US_2:     ${{ secrets.BLIZZARD_CLIENT_ID_US_2 }}
      BLIZZARD_CLIENT_SECRET_US_2: ${{ secrets.BLIZZARD_CLIENT_SECRET_US_2 }}
      BLIZZARD_CLIENT_ID_TW_2:     ${{ secrets.BLIZZARD_CLIENT_ID_TW_2 }}
      BLIZZARD_CLIENT_SECRET_TW_2: ${{ secrets.BLIZZARD_CLIENT_SECRET_TW_2 }}
      BLIZZARD_CLIENT_ID_KR_2:     ${{ secrets.BLIZZARD_CLIENT_ID_KR_2 }}
      BLIZZARD_CLIENT_SECRET_KR_2: ${{ secrets.BLIZZARD_CLIENT_SECRET_KR_2 }}
      
      BLIZZARD_CLIENT_ID_EU_3:     ${{ secrets.BLIZZARD_CLIENT_ID_EU_3 }}
      BLIZZARD_CLIENT_SECRET_EU_3: ${{ secrets.BLIZZARD_CLIENT_SECRET_EU_3 }}
      BLIZZARD_CLIENT_ID_US_3:     ${{ secrets.BLIZZARD_CLIENT_ID_US_3 }}
      BLIZZARD_CLIENT_SECRET_US_3: ${{ secrets.BLIZZARD_CLIENT_SECRET_US_3 }}
      BLIZZARD_CLIENT_ID_TW_3:     ${{ secrets.BLIZZARD_CLIENT_ID_TW_3 }}
      BLIZZARD_CLIENT_SECRET_TW_3: ${{ secrets.BLIZZARD_CLIENT_SECRET_TW_3 }}
      BLIZZARD_CLIENT_ID_KR_3:     ${{ secrets.BLIZZARD_CLIENT_ID_KR_3 }}
      BLIZZARD_CLIENT_SECRET_KR_3: ${{ secrets.BLIZZARD_CLIENT_SECRET_KR_3 }}
      
      BLIZZARD_CLIENT_ID_EU_4:     ${{ secrets.BLIZZARD_CLIENT_ID_EU_4 }}
      BLIZZARD_CLIENT_SECRET_EU_4: ${{ secrets.BLIZZARD_CLIENT_SECRET_EU_4 }}
      BLIZZARD_CLIENT_ID_US_4:     ${{ secrets.BLIZZARD_CLIENT_ID_US_4 }}
      BLIZZARD_CLIENT_SECRET_US_4: ${{ secrets.BLIZZARD_CLIENT_SECRET_US_4 }}
      BLIZZARD_CLIENT_ID_TW_4:     ${{ secrets.BLIZZARD_CLIENT_ID_TW_4 }}
      BLIZZARD_CLIENT_SECRET_TW_4: ${{ secrets.BLIZZARD_CLIENT_SECRET_TW_4 }}
      BLIZZARD_CLIENT_ID_KR_4:     ${{ secrets.BLIZZARD_CLIENT_ID_KR_4 }}
      BLIZZARD_CLIENT_SECRET_KR_4: ${{ secrets.BLIZZARD_CLIENT_SECRET_KR_4 }}
      
      BLIZZARD_CLIENT_ID_EU_5:     ${{ secrets.BLIZZARD_CLIENT_ID_EU_5 }}
      BLIZZARD_CLIENT_SECRET_EU_5: ${{ secrets.BLIZZARD_CLIENT_SECRET_EU_5 }}
      BLIZZARD_CLIENT_ID_US_5:     ${{ secrets.BLIZZARD_CLIENT_ID_US_5 }}
      BLIZZARD_CLIENT_SECRET_US_5: ${{ secrets.BLIZZARD_CLIENT_SECRET_US_5 }}
      BLIZZARD_CLIENT_ID_TW_5:     ${{ secrets.BLIZZARD_CLIENT_ID_TW_5 }}
      BLIZZARD_CLIENT_SECRET_TW_5: ${{ secrets.BLIZZARD_CLIENT_SECRET_TW_5 }}
      BLIZZARD_CLIENT_ID_KR_5:     ${{ secrets.BLIZZARD_CLIENT_ID_KR_5 }}
      BLIZZARD_CLIENT_SECRET_KR_5: ${{ secrets.BLIZZARD_CLIENT_SECRET_KR_5 }}
      
      BLIZZARD_CLIENT_ID_EU_429:     ${{ secrets.BLIZZARD_CLIENT_ID_EU_429 }}
      BLIZZARD_CLIENT_SECRET_EU_429: ${{ secrets.BLIZZARD_CLIENT_SECRET_EU_429 }}
      BLIZZARD_CLIENT_ID_US_429:     ${{ secrets.BLIZZARD_CLIENT_ID_US_429 }}
      BLIZZARD_CLIENT_SECRET_US_429: ${{ secrets.BLIZZARD_CLIENT_SECRET_US_429 }}
      BLIZZARD_CLIENT_ID_TW_429:     ${{ secrets.BLIZZARD_CLIENT_ID_TW_429 }}
      BLIZZARD_CLIENT_SECRET_TW_429: ${{ secrets.BLIZZARD_CLIENT_SECRET_TW_429 }}
      BLIZZARD_CLIENT_ID_KR_429:     ${{ secrets.BLIZZARD_CLIENT_ID_KR_429 }}
      BLIZZARD_CLIENT_SECRET_KR_429: ${{ secrets.BLIZZARD_CLIENT_SECRET_KR_429 }}
    outputs:
      matrix: ${{ steps.matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up Python
        uses: actions/setup-python@v5
        with: { python-version: '3.13' }
      - name: Install deps
        run: pip install aiohttp requests psutil
      - name: Resolve region list (supports 'all' or blank → all regions)
        id: resolve_regions
        shell: bash
        run: |
          set -euo pipefail
          in="${{ inputs.region || '' }}"
          if [[ -z "$in" || "$in" == "all" ]]; then
            REGIONS="us eu tw kr"
          else
            REGIONS="$in"
          fi
          echo "REGIONS=$REGIONS" >> "$GITHUB_ENV"
          echo "Region selection -> ${REGIONS}"
      - name: Ensure usable region Lua files are present (dev/main aware, no LFS)
        id: seed_luas
        shell: bash
        run: |
          set -euo pipefail

          # prefer the current ref; fall back to main for prod repos or dev for dev repos
          REF="${{ github.ref_name }}"
          FALLBACK_REF="$REF"
          if [[ "$FALLBACK_REF" != "main" && "$FALLBACK_REF" != "dev" ]]; then
            # if the current ref is a tag/feature branch, prefer main
            FALLBACK_REF="main"
          fi

          echo "Current ref: $REF ; fallback ref: $FALLBACK_REF"

          is_real () { [[ -s "$1" ]] && ! head -n2 "$1" | grep -qi 'git-lfs.github.com/spec'; }

          # repo-root only
          have_real=0
          for f in ./region_*.lua; do
            [[ -e "$f" ]] || continue
            if is_real "$f"; then have_real=$((have_real+1)); fi
          done

          if (( have_real > 0 )); then
            echo "Found $have_real usable region Lua file(s) in workspace."
            exit 0
          fi

          echo "::warning::No usable region Lua files in workspace. Pulling from $FALLBACK_REF…"

          git fetch --no-tags --depth=1 origin "$FALLBACK_REF"

          # Only repo-root files from that ref
          mapfile -t CANDIDATES < <(git ls-tree --name-only "origin/$FALLBACK_REF" |
                                    grep -E '^region_(us|eu|tw|kr)((_part[0-9]+)|(-[0-9]+))?\.lua$')

          if (( ${#CANDIDATES[@]} > 0 )); then
            git checkout "origin/$FALLBACK_REF" -- "${CANDIDATES[@]}" || true
          fi

          have_real=0
          for f in ./region_*.lua; do
            [[ -e "$f" ]] || continue
            if is_real "$f"; then have_real=$((have_real+1)); fi
          done

          if (( have_real == 0 )); then
            echo "::warning::Still no usable region Lua files after fallback fetch; dispatcher will use bracket-only counts."
          else
            echo "✅ Seeded $have_real region Lua file(s) from $FALLBACK_REF."
          fi
      - name: Build batch matrix
        id: matrix
        shell: bash
        run: |
          ITEMS=()
          for region in $REGIONS; do
            # list-ids-only now: repo-root union bracket → merged set
            TOTAL=$(python sync_pvp.py --list-ids-only --region "$region" | wc -l)
            COUNT=$(( (TOTAL + BATCH_SIZE - 1) / BATCH_SIZE ))
            echo "=== Region=$region | TOTAL Chars=$TOTAL | COUNT batches=$COUNT ==="
          # How many credential suffixes needed to stay under sliding-window cap (~36k/hour)
          PREFIXES=($(echo $SUFFIX_LIST | tr -d '"' | tr ',' ' '))
          MAX_PREF=${#PREFIXES[@]}
          CREDS_NEEDED=$(( (COUNT + MAX_BATCHES_PER_CRED - 1) / MAX_BATCHES_PER_CRED ))
          [ "$CREDS_NEEDED" -lt 1 ] && CREDS_NEEDED=1
          echo "Suffix list parsed (${MAX_PREF}): ${PREFIXES[*]}"
          echo "CREDS_NEEDED -> $CREDS_NEEDED"
          # Cap to available suffixes
          if (( CREDS_NEEDED > MAX_PREF )); then
            CREDS_NEEDED=$MAX_PREF
          fi
          SUFFIXES=("${PREFIXES[@]:0:$CREDS_NEEDED}")
          echo "Using suffixes: ${SUFFIXES[*]}"
          for ((i=0;i<COUNT;i++)); do
            OFFSET=$(( i * BATCH_SIZE ))
            # Round-robin assignment: low usage
            IDX=$(( i % CREDS_NEEDED ))
            SUFFIX=${SUFFIXES[$IDX]}
            ITEMS+=("{\"region\":\"$region\",\"offset\":$OFFSET,\"batch_id\":$i,\"total_batches\":$COUNT,\"cred_suffix\":\"$SUFFIX\",\"cred_spacing\":$CREDS_NEEDED}")
          done
          done
          # comma‑join
          m=$(printf ',%s' "${ITEMS[@]}")
          echo "matrix=[${m:1}]" >> $GITHUB_OUTPUT

  dispatch:
    needs: prepare
    runs-on: ubuntu-latest
    steps:
      - name: Fire off the first batch per region
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const matrix = JSON.parse(process.env.MATRIX);
            const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
            const rootId = process.env.GROUP_ID;  // dispatcher run id

            // Dispatch the first batch for each region‑suffix combination
            const grouped = matrix.reduce((acc, j) => {
              const key = `${j.region}|${j.cred_suffix}`;
              if (!acc[key] || j.batch_id < acc[key].batch_id) {
                acc[key] = j;
              }
              return acc;
            }, {});
            const firstBatches = Object.values(grouped);

            for (const job of firstBatches) {
              const groupKey = `${job.region}-${rootId}`;
              await github.rest.actions.createWorkflowDispatch({
                owner,
                repo,
                workflow_id: 'pvp-sync-batch.yml',
                ref: context.ref,
                inputs: {
                  region:        job.region,
                  offset:        String(job.offset),
                  limit:         String(process.env.BATCH_SIZE),
                  batch_id:      String(job.batch_id),
                  batch_num:     String(job.batch_id + 1),
                  total_batches: String(job.total_batches),
                  "cred_suffix": String(job.cred_suffix),
                  "cred_spacing": String(job.cred_spacing),
                  "group-id":    String(groupKey)
                }
              });
              core.info(`▶️ Dispatched ${job.region}@${job.offset} (group ${groupKey})`);
            }
        env:
          MATRIX:     ${{ needs.prepare.outputs.matrix }}
          GROUP_ID:   ${{ github.run_id }}
          BATCH_SIZE: ${{ env.BATCH_SIZE }}
